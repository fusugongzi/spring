###常用注解

- @Autowired spring提供的, 通过类型注入，如果一个类型有多个bean存在，必须通过搭配@Qualifier(value = "xxx")注解使用，指定对应的bean，不然会报错。
- @Resource javax提供的, 默认通过名字注入,其次通过类型注入，若一个类型有多个bean存在，且没有和要注入的属性名字相同的bean存在，则需要指定name,@Resource(name = "cat1")
- @Nullable 指定说明属性可以为空

- @Component spring提供的，标注一个类是组件，交给spring管理。
@Service @Reposity @Controller这三个注解和@Component是一样的，只是根据spring mvc的三层进行了区分而已。
-@Value 注入属性，可用与属性或者set方法上面


# 代理
  代理分为静态代理和动态代理。
  
## 静态代理
角色：
  
   抽象角色：通过接口或者抽象类实现，指要做的事情。
      
   真实角色：被代理的角色。
   
   代理角色：代理真实角色，代理真实角色后，会做一些附属操作。
   
   客户：    访问代理对象的人。
   
代理模式的好处:

1.可以使真实角色的操作更加纯粹!不用去关注一些公共业务。

2.公共业务交给代理角色！实现了业务分工。

3.公共业务发生扩展时，方便集中管理。

缺点：

1.一个真实角色就会产生一个代理角色;代码量会翻一倍，开发效率降低。

##动态代理
动态代理角色和静态代理角色一样。

动态代理的类是通过反射动态生成的，不是我们自己写好的。

动态代理分为两大类: 基于接口的动态代理 和 基于类的动态代理。


基于接口的动态代理 -- jdk动态代理 我们在这里使用

基于类的动态代理 -- cglib

java字节码实现 -- javasist, jboss服务器是这样实现的

需要了解两个类 Proxy 和 InvocationHandler

InvocationHandler: 实现了通过反射调用方法的逻辑，可以在这里面自定义一些公共的业务逻辑。

Proxy: 提供了得到代理类的方法。

具体代码实现: 参考com.study.proxy.demo04.MyInvocationHandler

动态代理的好处:

不需要为每个具体角色类都新建一个代理角色类，而且不需要重写具体角色的每个方法，十分方便简洁。

#使用spring实现Aop
##方式一:使用Spring的API接口


##方式二:自定义类来实现AOP

横切关注点: 与业务逻辑无关，但是我们需要关注的部分。比如：日志，安全等

切入点: 切面通知执行的地点。也就是要从哪里添加我们的东西。

切面: 横切关注点模块化的特殊对象,也就是一个类。

通知: 切面要完成的工作,即,它是类中的一个方法。

#整合mybatis

#声明式事务
1、事务ACID原则
2、事务分为两种
声明式事务: AOP

编程式事务:直接写代码

#面向对象七大原则

#总结





